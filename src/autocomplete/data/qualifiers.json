{
  "$schema": "./$schema.json",
  "const": {
    "if": "empty",
    "desc": "The qualifier `const` is used for variables that are compile-time constants or for function parameters that are `read-only`."
  },
  "attribute": {
    "if": "empty",
    "desc": "The qualifier `attribute` is used to declare variables that are shared between a vertex shader and the OpenGL ES environment. \n\nSince the vertex shader is executed one time for each vertex attributes are used to specify per vertex data. They typically provide data such as the object space position, the normal direction and the texture coordinates of a vertex. Attributes are read-only variables, i.e. their value can not be changed in the vertex shader. \n\nSide note: Since an attribute is never initialized in the shader it has to be loaded with data by the application executing the shader."
  },
  "uniform": {
    "if": "empty",
    "desc": "The qualifier `uniform` is used to declare variables that are shared between a shader and the OpenGL ES environment.\n\nUniforms can be used in the vertex shader and the fragment shader and they must have global scope. The same uniform variable can be used in the vertex and the fragment shader, but since both shaders share the same name space the declaration has to be identical. Uniforms are used to specify properties of the object that is rendered. Examples are the projection matrix, the light position or the material color of the object. Uniforms are `read-only` variables, i.e. their value can not be changed in the shader.\n\nSide note: Since a uniform is never initialized in the shader it has to be loaded with data by the application executing the shader."
  },
  "varying": {
    "if": "empty",
    "desc": "The qualifier `varying` is used to declare variables that are shared between the vertex shader and the fragment shader.\n\nVarying are used for information that is calculated in the vertex shader and should be handed over to the fragment shader. Both shaders have to declare the varying and the declarations must be identical. The vertex shader initializes the varying for each vertex. After that the per vertex data of the varying is interpolated during rasterization before being handed over to the fragment shader.\n\nThe varying qualifier can only be used with floating point scalar, floating point vectors and (floating point) matrices as well as arrays containing these types."
  },
  "highp": {
    "if": "empty",
    "desc": "The qualifier `highp` is used to specify the highest available precision for a variable. The variable has to be an integer or a floating point scalar or a vector or matrix based on these types. The precision qualifier precedes the type in the variable declaration.\n\nIn the vertex shader the use of a precision qualifier is optional. If no qualifier is given all variables are of highest precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.\n\n```glsl\nuniform highp vec3 lightDirection;\n```\n\nThe actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations."
  },
  "mediump": {
    "if": "empty",
    "desc": "The qualifier `mediump` is used to specify a precision between the highest and lowest available precision for a variable. The variable has to be an integer or a floating point scalar or a vector or matrix based on these types. The precision qualifier precedes the type in the variable declaration.\n\nIn the vertex shader the use of a precision qualifier is optional. If no qualifier is given all variables are of highest precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.\n\n```glsl\nvarying mediump vec2 textureCoordinate;\n```\n\nThe actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations."
  },
  "lowp": {
    "if": "empty",
    "desc": "The qualifier `lowp` is used to specify the lowest available precision for a variable. The variable has to be an integer or a floating point scalar or a vector or matrix based on these types. The precision qualifier precedes the type in the variable declaration.\n\nIn the vertex shader the use of a precision qualifier is optional. If no qualifier is given all variables are of highest precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.\n\n```glsl\nvarying lowp vec4 colorVarying;\n```\n\nThe actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations."
  },
  "precision": {
    "if": "empty",
    "desc": "The keyword `precision` is used in conjunction with a precision qualifier and a data type to specify the default precision for that data type. The type has to be an integer or a floating point scalar or a vector or matrix based on these types.\n\nIn the vertex shader all variables are of highest precision by default. The default can be changed defining another default precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.\n\n```glsl\n\nprecision highp float;\n```\n\nThe actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations."
  },
  "in": {
    "desc": "The qualifier `in` is used to mark a parameter as read-only when a function is declared. The parameter will be passed by value to the function and the value can not be modified by the function.\n\n```glsl\nint newFunction(in bvec4 aBvec4,   // read-only \nout vec3 aVec3,    // write-only\ninout int aInt);   // read-write\n```\n\nThe above function declaration shows the three possible parameter qualifiers. The usage of the read-only qualifier is not necessary since this is the default if no qualifier is specified.",
    "if": "parameter"
  },
  "out": {
    "desc": "The qualifier `out` is used to mark a parameter as write-only when a function is declared. The parameter will be passed by reference to the function but it is not initialized, i.e. the value can not be read. The value can be modified by the function and the changes are preserved after the function exits.\n\n```glsl\n\nint newFunction(in bvec4 aBvec4,   // read-only\nout vec3 aVec3,    // write-only\ninout int aInt);   // read-write\n```\n\nThe above function declaration shows the three possible parameter qualifiers. The usage of the read-only qualifier is not necessary since this is the default if no qualifier is specified.",
    "if": "parameter"
  },
  "inout": {
    "desc": "The qualifier `inout` is used to mark a parameter as read-write when a function is declared. The parameter will be passed by reference to the function and is initialized, i.e. the value can be read. The value can be modified by the function and the changes are preserved after the function exits.\n\n```glsl\nint newFunction(in bvec4 aBvec4,   // read-only\nout vec3 aVec3,    // write-only\ninout int aInt);   // read-write\n```\n\nThe above function declaration shows the three possible parameter qualifiers. The usage of the read-only qualifier is not necessary since this is the default if no qualifier is specified.",
    "if": "parameter"
  }
}
